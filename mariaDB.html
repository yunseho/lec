<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    hello World!{{title}}<br>
    아이디:{{user_id}}
    패스워드:{{user_pw}}

    <form method = "post" id= "" action = "http://localhost:3000"><!--form 안의 input 내용을 http://localhost:3000으로 보냄 구조:html>server>html 상호작용함 submit 해서 reload를 발생시킴-->
        <!--node.js는 post 내장함수를 없앴다. 그래서 저 문서를 해독하고 원하는 부분을 뽑아서 쓸 수 있도록 코딩해야함.-->
        이름:<input type = "text"  name = "name">
        아이디:<input type = "text" name = "id"><!--여기 id쓰면 모든게 다 해결됨. 여기에 user_id쓰면 new.js에 있는 있는 요청.query.id값을 요청.query.id로 바꿔주어야함.-->
        패스워드:<input type = "text" name = "pw">
        <!--순서대로 올라감 아이디,이름,패스워드 순이라면 url도 바뀌면서 링크 이동이 됨.-->
        <input type = "submit" value = "버튼"><!--버튼과 똑같지만 기능 다름 나를 감싸는 폼이 실행되는 거임. 받는 값을 name으로 해줘야 함. input 안의 값이 url로 올라감.
        -->
    </form>
</body>
</html>

브라우저1의 요청 -> 서버(http)가 받고 답 브라우저 1에게 전송
DBMS는 서버의 요청이 있을 때 정보를 제공 

*브라우저의 요청 -> 서버가 받고 -> dbms에게 요청
dbms는 서버에게 전송->서버는 다시 브라우저에게 전송


DBMS는 여러가지의 정보를 담은 엑셀파일 이라 생각하면 된다
아아디 값( 아이디 ,패스워드 ,이름)만 모아논 것 /  필드
데이더 값(아이디의 데이터값)을 모아논 것   레코드

필드가 위에 있고 레코드가 하나씩 추가되서 계속 쌓이는게 테이블이다


show databases;     데이터베이스 목록을 보여준다
Database 밑에 있는것은 엑셀파일들과 같다 

use 데이터베이스 파일명;     데이터베이스 파일을 킨다는 뜻
show tables;    테이블안에 있는 시트를 보여준다 

select * from user    //  
select(필드) *(모든필드 아이디부터~패스워드까지) from[테이블명]      

insert into [테이블명] (필드1,필드2...) valuse(값1,값2...)
ex)insert into user(userid,name,password) valuse('test1','test2')

DELETE FROM [테이블명] WHERE 필드 = 값;
delete from user where name='test'


실습
ingoo 데이터베이스   User 테이블

1.create database ingoo;  //ingoo라는 데이터베이스 파일 생성

2.use ingoo;  // ingoo를 실행

3.show tables;  // ingoo내 table 목록보기

4-1.테이블명 지어주기 // user라고 설정하기 근데 필드영역까지 같이 한번에 해야함
create table 테이블명(필드명 레코드타입);

create table user(         //세미콜론이 없으면 이어서 친다는 듯
userid varchar(50),              //글자의 종류와 사이즈를 넣는 곳 쉼표쓰는것 중요 
userpw varchar(50),
username varchar(50)
);
4-2.필드영역에 이름을 정해주기 // 3개할거임
userid
userpw
username

5.필드생성 확인 
show tables;

6.필드 영역 보기
desc user;     //테이블명 입력
3 rows in set //3개의 필드가 생성됨

7.필드영역 채우기 //(레코드)데이터값 입력하기

insert into user(userid,userpw,username) values('web7722','1234','곽인구');
insert into user(userid,userpw,username) values('test','1234','길동이');
insert into user(userid,userpw,username) values('sample','1234','홍길동');
insert into user(userid,userpw,username) values('nodejs','1234','노드');
insert into user(userid,userpw,username) values('js','1234','둘리');

8.필드영역 채운것 확인
select * from user;

9.userid 필드에서 레코드 text 라인만 날리겠다는 듯
delete from user where userid = 'sample'

10.필드영역 정렬하기
select * from user order by userid asc;  / 오름차순 정렬
select * from user order by userid des;  /  내림차순 정렬

11.레코드값 수정하기
update user[테이블명] set username='홍길동2[변경할이름]' where username='홍길동[변경대상]'; 
update user set username='홍길동2 'where username='홍길동'; 

*숙제*
PK : primary key    / alter table
select 문 option 값
                    검색기능(%)의 활용
                    limit 
NOT NULL?
TYPE에 대해서 조사  varchar(50)
auto increment
ilmit기능










